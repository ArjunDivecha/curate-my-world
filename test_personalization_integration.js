#!/usr/bin/env node
/**
 * =============================================================================
 * SCRIPT NAME: test_personalization_integration.js
 * =============================================================================
 * 
 * INPUT FILES:
 * - demo_outputs/curation_prompt_[timestamp].json: Generated by user input processor
 * 
 * OUTPUT FILES:
 * - integration_test_results.json: Test results and performance metrics
 * - personalized_events_[session].json: Generated by personalization API
 * 
 * DESCRIPTION:
 * Integration test script that demonstrates the complete workflow from user input
 * processing to personalized event curation. Tests the connection between the
 * user input processor and the backend personalization API.
 * 
 * WORKFLOW:
 * 1. Load curation prompt from user input processor output
 * 2. Send request to personalization API
 * 3. Validate response and generated events
 * 4. Generate integration test report
 * 
 * VERSION: 1.0
 * LAST UPDATED: 2025-08-01
 * AUTHOR: Arjun Divecha
 * =============================================================================
 */

import fs from 'fs/promises';
import path from 'path';
// Use native fetch (Node 18+) or import if needed
const fetch = globalThis.fetch || (await import('node-fetch')).default;

class PersonalizationIntegrationTester {
  constructor() {
    this.apiBaseUrl = 'http://localhost:3000';
    this.testResults = {
      startTime: new Date().toISOString(),
      tests: [],
      summary: {
        passed: 0,
        failed: 0,
        total: 0
      }
    };
  }

  /**
   * Run the complete integration test suite
   */
  async runIntegrationTests() {
    console.log('ðŸ§ª CURATE MY WORLD - PERSONALIZATION INTEGRATION TEST');
    console.log('='.repeat(60));
    
    try {
      // Test 1: Load curation prompt from user input processor
      await this.testLoadCurationPrompt();
      
      // Test 2: Test API connectivity
      await this.testApiConnectivity();
      
      // Test 3: Send personalization request
      await this.testPersonalizationRequest();
      
      // Test 4: Validate response structure
      await this.testResponseValidation();
      
      // Test 5: Check output files
      await this.testOutputFiles();
      
      // Generate final report
      await this.generateTestReport();
      
    } catch (error) {
      console.error('âŒ Integration test failed:', error.message);
      this.addTestResult('Integration Test Suite', false, error.message);
    }
    
    this.printTestSummary();
  }

  /**
   * Test loading curation prompt from user input processor output
   */
  async testLoadCurationPrompt() {
    console.log('\nðŸ“‹ Test 1: Loading Curation Prompt');
    console.log('-'.repeat(35));
    
    try {
      // Find the most recent curation prompt file
      const demoOutputsDir = 'demo_outputs';
      const files = await fs.readdir(demoOutputsDir);
      const curationFiles = files.filter(f => f.startsWith('curation_prompt_'));
      
      if (curationFiles.length === 0) {
        throw new Error('No curation prompt files found. Run demo_user_input.py first.');
      }
      
      // Get the most recent file
      const latestFile = curationFiles.sort().reverse()[0];
      const filePath = path.join(demoOutputsDir, latestFile);
      
      console.log(`ðŸ“„ Loading: ${filePath}`);
      
      const fileContent = await fs.readFile(filePath, 'utf-8');
      this.curationPrompt = JSON.parse(fileContent);
      
      // Validate required fields
      const requiredFields = [
        'metadata',
        'user_profile',
        'curation_parameters',
        'data_sources'
      ];
      
      for (const field of requiredFields) {
        if (!this.curationPrompt[field]) {
          throw new Error(`Missing required field: ${field}`);
        }
      }
      
      console.log('âœ… Curation prompt loaded successfully');
      console.log(`ðŸ“ Location: ${this.curationPrompt.user_profile.location.primary_location}`);
      console.log(`ðŸŽ¯ Interests: ${Object.keys(this.curationPrompt.user_profile.interests).length} categories`);
      console.log(`âš™ï¸  Max Events: ${this.curationPrompt.curation_parameters.max_events_per_week}`);
      
      this.addTestResult('Load Curation Prompt', true, 'Successfully loaded and validated curation prompt');
      
    } catch (error) {
      console.log(`âŒ Failed to load curation prompt: ${error.message}`);
      this.addTestResult('Load Curation Prompt', false, error.message);
      throw error;
    }
  }

  /**
   * Test API connectivity
   */
  async testApiConnectivity() {
    console.log('\nðŸ”— Test 2: API Connectivity');
    console.log('-'.repeat(25));
    
    try {
      console.log(`ðŸŒ Testing connection to: ${this.apiBaseUrl}`);
      
      const response = await fetch(`${this.apiBaseUrl}/api/health`);
      
      if (!response.ok) {
        throw new Error(`API health check failed: ${response.status} ${response.statusText}`);
      }
      
      const healthData = await response.json();
      console.log('âœ… API is healthy');
      console.log(`ðŸ“Š Status: ${healthData.status}`);
      console.log(`â±ï¸  Response Time: ${healthData.responseTime}`);
      
      this.addTestResult('API Connectivity', true, 'API health check passed');
      
    } catch (error) {
      console.log(`âŒ API connectivity failed: ${error.message}`);
      console.log('ðŸ’¡ Make sure the backend server is running: npm start');
      this.addTestResult('API Connectivity', false, error.message);
      throw error;
    }
  }

  /**
   * Test personalization request
   */
  async testPersonalizationRequest() {
    console.log('\nðŸŽ¯ Test 3: Personalization Request');
    console.log('-'.repeat(32));
    
    try {
      console.log('ðŸ“¤ Sending personalization request...');
      
      const startTime = Date.now();
      
      const response = await fetch(`${this.apiBaseUrl}/api/personalization/curate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(this.curationPrompt)
      });
      
      const responseTime = Date.now() - startTime;
      
      if (!response.ok) {
        const errorData = await response.text();
        throw new Error(`Personalization request failed: ${response.status} ${response.statusText}\n${errorData}`);
      }
      
      this.personalizationResponse = await response.json();
      
      console.log('âœ… Personalization request successful');
      console.log(`â±ï¸  Response Time: ${responseTime}ms`);
      console.log(`ðŸŽª Events Found: ${this.personalizationResponse.count}`);
      console.log(`ðŸ“‹ Session ID: ${this.personalizationResponse.sessionId}`);
      
      this.addTestResult('Personalization Request', true, `Found ${this.personalizationResponse.count} events in ${responseTime}ms`);
      
    } catch (error) {
      console.log(`âŒ Personalization request failed: ${error.message}`);
      this.addTestResult('Personalization Request', false, error.message);
      throw error;
    }
  }

  /**
   * Test response validation
   */
  async testResponseValidation() {
    console.log('\nâœ… Test 4: Response Validation');
    console.log('-'.repeat(28));
    
    try {
      const response = this.personalizationResponse;
      
      // Check required response fields
      const requiredFields = ['success', 'sessionId', 'events', 'count', 'curationReport'];
      
      for (const field of requiredFields) {
        if (response[field] === undefined) {
          throw new Error(`Missing required response field: ${field}`);
        }
      }
      
      console.log('âœ… Response structure is valid');
      
      // Validate events structure
      if (response.events.length > 0) {
        const sampleEvent = response.events[0];
        const eventFields = ['title', 'description', 'date', 'venue'];
        
        for (const field of eventFields) {
          if (!sampleEvent[field]) {
            console.log(`âš ï¸  Warning: Event missing field '${field}'`);
          }
        }
        
        // Check personalization metadata
        if (sampleEvent._personalization) {
          console.log('âœ… Events contain personalization metadata');
          console.log(`ðŸŽ¯ Sample Score: ${sampleEvent._personalization.personalizedScore?.toFixed(3)}`);
          console.log(`ðŸ“‚ Sample Category: ${sampleEvent._personalization.category}`);
        } else {
          console.log('âš ï¸  Warning: Events missing personalization metadata');
        }
      }
      
      // Validate curation report
      const report = response.curationReport;
      if (report.user_profile_summary && report.curation_results) {
        console.log('âœ… Curation report is comprehensive');
        console.log(`ðŸ“Š Events Collected: ${report.curation_results.total_events_collected}`);
        console.log(`ðŸŽ¯ Events After Personalization: ${report.curation_results.events_after_personalization}`);
        console.log(`â­ Avg Score: ${report.personalization_insights.average_personalization_score?.toFixed(3)}`);
      }
      
      this.addTestResult('Response Validation', true, 'Response structure and content validated');
      
    } catch (error) {
      console.log(`âŒ Response validation failed: ${error.message}`);
      this.addTestResult('Response Validation', false, error.message);
      throw error;
    }
  }

  /**
   * Test output files generation
   */
  async testOutputFiles() {
    console.log('\nðŸ“ Test 5: Output Files');
    console.log('-'.repeat(20));
    
    try {
      const outputFiles = this.personalizationResponse.outputFiles || [];
      
      if (outputFiles.length === 0) {
        throw new Error('No output files were generated');
      }
      
      console.log(`ðŸ“„ Generated ${outputFiles.length} output files:`);
      
      for (const filePath of outputFiles) {
        try {
          const stats = await fs.stat(filePath);
          const fileName = path.basename(filePath);
          console.log(`  âœ… ${fileName} (${stats.size} bytes)`);
          
          // Validate file content
          if (fileName.includes('personalized_events')) {
            const content = await fs.readFile(filePath, 'utf-8');
            const data = JSON.parse(content);
            console.log(`     ðŸ“Š Contains ${data.count} events`);
          }
          
        } catch (fileError) {
          console.log(`  âŒ ${path.basename(filePath)} - Error: ${fileError.message}`);
        }
      }
      
      this.addTestResult('Output Files', true, `Generated ${outputFiles.length} output files`);
      
    } catch (error) {
      console.log(`âŒ Output files test failed: ${error.message}`);
      this.addTestResult('Output Files', false, error.message);
    }
  }

  /**
   * Add test result to results collection
   */
  addTestResult(testName, passed, message) {
    this.testResults.tests.push({
      name: testName,
      passed,
      message,
      timestamp: new Date().toISOString()
    });
    
    if (passed) {
      this.testResults.summary.passed++;
    } else {
      this.testResults.summary.failed++;
    }
    
    this.testResults.summary.total++;
  }

  /**
   * Generate comprehensive test report
   */
  async generateTestReport() {
    console.log('\nðŸ“Š Generating Test Report...');
    
    this.testResults.endTime = new Date().toISOString();
    this.testResults.duration = Date.now() - new Date(this.testResults.startTime).getTime();
    
    // Add additional metrics if personalization was successful
    if (this.personalizationResponse) {
      this.testResults.personalizationMetrics = {
        eventsFound: this.personalizationResponse.count,
        sessionId: this.personalizationResponse.sessionId,
        processingTime: this.personalizationResponse.processingTime,
        curationReport: this.personalizationResponse.curationReport
      };
    }
    
    // Save test report
    const reportPath = 'integration_test_results.json';
    await fs.writeFile(reportPath, JSON.stringify(this.testResults, null, 2));
    
    console.log(`ðŸ“„ Test report saved: ${reportPath}`);
  }

  /**
   * Print test summary
   */
  printTestSummary() {
    console.log('\n' + '='.repeat(60));
    console.log('ðŸ“‹ INTEGRATION TEST SUMMARY');
    console.log('='.repeat(60));
    
    console.log(`âœ… Passed: ${this.testResults.summary.passed}`);
    console.log(`âŒ Failed: ${this.testResults.summary.failed}`);
    console.log(`ðŸ“Š Total: ${this.testResults.summary.total}`);
    console.log(`â±ï¸  Duration: ${this.testResults.duration}ms`);
    
    if (this.testResults.summary.failed === 0) {
      console.log('\nðŸŽ‰ ALL TESTS PASSED! The personalization integration is working correctly.');
      console.log('\nðŸš€ Next Steps:');
      console.log('1. Check the generated personalized events in the output files');
      console.log('2. Review the curation report for insights');
      console.log('3. Test with different user preferences');
      console.log('4. Integrate with your frontend application');
    } else {
      console.log('\nâš ï¸  Some tests failed. Check the errors above and ensure:');
      console.log('1. The backend server is running (npm start)');
      console.log('2. All required dependencies are installed');
      console.log('3. The user input processor has generated demo data');
    }
    
    console.log('\n' + '='.repeat(60));
  }
}

// Run the integration tests
async function main() {
  const tester = new PersonalizationIntegrationTester();
  await tester.runIntegrationTests();
}

// Handle command line execution
if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch(error => {
    console.error('Integration test suite failed:', error);
    process.exit(1);
  });
}

export default PersonalizationIntegrationTester;
